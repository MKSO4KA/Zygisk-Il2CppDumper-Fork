import org.apache.tools.ant.filters.FixCrLfFilter
import java.nio.file.Paths
import java.nio.file.Files

// Используем новый блок plugins для подключения плагина.
// Это стандарт для современных версий Gradle.
plugins {
    id 'com.android.library'
}

apply from: file(rootProject.file('module.gradle'))

// ===================================================================
// ===== НАЧАЛО: Задача для автоматического увеличения версии =======
// ===================================================================

task bumpVersion {
    description "Increments the patch version and version code in gradle.properties."
    group "versioning"

    doLast {
        def propsFile = rootProject.file('gradle.properties')
        if (!propsFile.exists()) {
            throw new FileNotFoundException("gradle.properties not found!")
        }

        def properties = new Properties()
        propsFile.withInputStream {
            properties.load(it)
        }

        def currentPatch = properties.getProperty('VERSION_PATCH', '0').toInteger()
        def currentCode = properties.getProperty('VERSION_CODE', '1').toInteger()

        def newPatch = currentPatch + 1
        def newCode = currentCode + 1

        properties.setProperty('VERSION_PATCH', newPatch.toString())
        properties.setProperty('VERSION_CODE', newCode.toString())

        propsFile.withOutputStream {
            properties.store(it, "Version properties updated by bumpVersion task")
        }

        def newVersionName = "v${properties.getProperty('VERSION_MAJOR')}.${properties.getProperty('VERSION_MINOR')}.${newPatch}"
        println "Version bumped to ${newVersionName} (Code ${newCode})"
    }
}

tasks.named("preBuild").configure {
    dependsOn bumpVersion
}

// ===================================================================
// ===== КОНЕЦ: Задача для автоматического увеличения версии =========
// ===================================================================


android {
    namespace 'zygisk.il2cppdumper'
    compileSdkVersion rootProject.ext.targetSdkVersion
    ndkVersion '25.2.9519653'
    defaultConfig {
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        externalNativeBuild {
            cmake {
                def configDumpBinary = DUMP_BINARY_ENABLED.toBoolean() ? "1" : "0"
                def configDumpCs = DUMP_CS_ENABLED.toBoolean() ? "1" : "0"

                arguments "-DMODULE_NAME:STRING=$moduleLibraryName",
                        "-DCONFIG_DUMP_BINARY=${configDumpBinary}",
                        "-DCONFIG_DUMP_CS=${configDumpCs}"
            }
        }
    }
    buildFeatures {
        prefab true
    }
    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.22.1"
        }
    }
}

repositories {
    mavenLocal()
}

def getModuleProps() {
    def propsFile = rootProject.file('gradle.properties')
    def properties = new Properties()
    propsFile.withInputStream { properties.load(it) }

    def major = properties.getProperty('VERSION_MAJOR')
    def minor = properties.getProperty('VERSION_MINOR')
    def patch = properties.getProperty('VERSION_PATCH')
    def code = properties.getProperty('VERSION_CODE')

    return [
            versionName: "v${major}.${minor}.${patch}",
            versionCode: code
    ]
}

// ===================================================================
// ===== НАЧАЛО: Новый, совместимый способ создания задач ==========
// ===================================================================
// Используем новый Variants API, который заменяет `libraryVariants.forEach`.
android.libraryVariants.all { variant ->
    def variantCapped = variant.name.capitalize()
    def variantLowered = variant.name.toLowerCase()

    def magiskDir = file("$outDir/magisk_module_$variantLowered")

    def adbDeviceArgs = provider {
        if (project.hasProperty('ADB_DEVICE_SERIAL') && !ADB_DEVICE_SERIAL.isEmpty()) {
            return ['-s', ADB_DEVICE_SERIAL]
        }
        return []
    }

    def prepareTask = tasks.register("prepareMagiskFiles${variantCapped}", Sync) {
        dependsOn(variant.assembleProvider)

        outputs.upToDateWhen { false }

        def templatePath = "$rootDir/template/magisk_module"
        into magiskDir
        from(templatePath) { exclude 'module.prop' }
        from(templatePath) {
            include 'module.prop'
            def props = getModuleProps()
            expand([
                    id         : magiskModuleId,
                    name       : moduleName,
                    version    : props.versionName,
                    versionCode: props.versionCode,
                    author     : moduleAuthor,
                    description: moduleDescription,
            ])
            filter(FixCrLfFilter.class, eol: FixCrLfFilter.CrLf.newInstance("lf"))
        }
        from("$buildDir/intermediates/stripped_native_libs/$variantLowered/out/lib") { into 'lib' }
        doLast {
            file("$magiskDir/zygisk").mkdir()
            fileTree("$magiskDir/lib").visit { f ->
                if (!f.directory) return
                def srcPath = Paths.get("${f.file.absolutePath}/lib${moduleLibraryName}.so")
                def dstPath = Paths.get("$magiskDir/zygisk/${f.path}.so")
                Files.move(srcPath, dstPath)
            }
            new File("$magiskDir/lib").deleteDir()
        }
    }

    def zipTask = tasks.register("zip${variantCapped}", Zip) {
        dependsOn(prepareTask)
        from magiskDir
        archiveFileName.set(provider {
            def props = getModuleProps()
            "${magiskModuleId.replace('_', '-')}-${props.versionName}-${variantLowered}.zip"
        })
        destinationDirectory.set(outDir)
    }

    tasks.register("push${variantCapped}", Exec) {
        dependsOn(zipTask)
        workingDir outDir
        doFirst {
            def zipName = zipTask.get().archiveFileName.get()
            commandLine = [android.adbExecutable] + adbDeviceArgs.get() + ["push", zipName, "/data/local/tmp/"]
            println "Executing command: " + commandLine.join(" ")
        }
    }

    def flashTask = tasks.register("flash${variantCapped}", Exec) {
        dependsOn("push${variantCapped}")
        doFirst {
            def zipName = zipTask.get().archiveFileName.get()
            def reinstallCommand = "'magisk --remove-module ${magiskModuleId} 2>/dev/null ; magisk --install-module /data/local/tmp/${zipName}'"
            commandLine = [android.adbExecutable] + adbDeviceArgs.get() + ["shell", "su", "-c", reinstallCommand]
            println "Executing command: " + commandLine.join(" ")
        }
    }

    def cleanupTask = tasks.register("cleanupRemoteZip${variantCapped}", Exec) {
        dependsOn(flashTask)
        doFirst {
            def zipName = zipTask.get().archiveFileName.get()
            commandLine = [android.adbExecutable] + adbDeviceArgs.get() + ["shell", "su", "-c", "'rm /data/local/tmp/${zipName}'"]
            println "Executing command: " + commandLine.join(" ")
        }
        ignoreExitValue = true
    }

    tasks.register("flashAndReboot${variantCapped}", Exec) {
        dependsOn(cleanupTask)
        doFirst {
            commandLine = [android.adbExecutable] + adbDeviceArgs.get() + ["shell", "reboot"]
            println "Executing command: " + commandLine.join(" ")
        }
        ignoreExitValue = true
    }

    // Привязываем финальную задачу (zip) к задаче сборки варианта
    variant.assembleProvider.get().finalizedBy(zipTask)
}
// ===================================================================
// ===== КОНЕЦ: Новый, совместимый способ создания задач ===========
// ===================================================================


// ===================================================================
// ===== НАЧАЛО: Скрипт для скачивания Dobby и других зависимостей =====
// ===================================================================

ext {
    depsUrl = "https://github.com/MKSO4KA/LsPosedBaseBridge/releases/download/v1.0.0-libs/lsBaseBridge-mod-deps-v1.0.zip.zip"
    jniDir = file("$projectDir/src/main/cpp")
    jniIncludeDir = file("$jniDir/include")
    jniLibsDir = file("$jniDir/libs")
    depsZip = file("$buildDir/tmp/dependencies.zip")
}

task downloadAndUnzipDependencies {
    description "Downloads and unzips all prebuilt JNI dependencies (Dobby)."
    group "build setup"

    outputs.dir(jniIncludeDir)
    outputs.dir(jniLibsDir)

    doLast {
        println "Downloading JNI dependencies from ${depsUrl}..."
        depsZip.getParentFile().mkdirs()
        ant.get(src: depsUrl, dest: depsZip)

        println "Download complete. Unzipping dependencies..."
        copy {
            from zipTree(depsZip)
            include 'include/**'
            into jniDir
        }
        copy {
            from zipTree(depsZip)
            include 'libs/**'
            into jniDir
        }

        println "Cleaning up temporary zip file..."
        depsZip.delete()
    }
}

tasks.named("preBuild").configure {
    dependsOn downloadAndUnzipDependencies
}

// ===================================================================
// ===== КОНЕЦ: Скрипт для скачивания Dobby и других зависимостей =====
// ===================================================================